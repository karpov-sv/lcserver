{% extends "template.html" %}

{% load filters %}

{% block ptitle %}Light Curve : Target {{ target_id }} : LCServer{% endblock %}

{% block title %}Interactive Light Curve Viewer{% endblock %}

{% block head %}
<!-- Plotly.js -->
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>

<style>
.control-panel {
    background-color: var(--bs-light);
    border: 1px solid var(--bs-border-color);
    border-radius: 0.375rem;
    padding: 1rem;
    margin-bottom: 1rem;
}

.source-control {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    margin-bottom: 0.25rem;
    border-radius: 0.25rem;
    background-color: var(--bs-body-bg);
}

.source-control:hover {
    background-color: var(--bs-secondary-bg);
}

.source-color {
    width: 30px;
    height: 30px;
    border-radius: 3px;
    margin-right: 0.5rem;
    border: 1px solid var(--bs-border-color);
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.color-input {
    position: absolute;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}

.source-label {
    flex: 1;
    margin-right: 0.5rem;
    font-weight: 500;
}

.source-info {
    color: var(--bs-secondary-color);
    font-size: 0.875rem;
    margin-right: 1rem;
}

.offset-control {
    width: 80px;
    margin-right: 0.5rem;
}

.size-control {
    width: 60px;
    margin-right: 0.5rem;
}

.maxerr-control {
    width: 80px;
    margin-right: 0.5rem;
}

.control-label {
    font-size: 0.875rem;
    color: var(--bs-secondary-color);
    margin-right: 0.5rem;
}

#loading-indicator {
    padding: 1rem;
    background-color: var(--bs-light);
    border: 1px solid var(--bs-border-color);
    border-radius: 0.375rem;
}

#loading-indicator .progress {
    box-shadow: inset 0 1px 2px rgba(0,0,0,.1);
}

#loading-status {
    font-weight: 500;
    font-size: 0.9rem;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
</style>
{% endblock %}

{% block content %}

<!-- Breadcrumb -->
<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    <li class="breadcrumb-item">
      <a href="{% url 'targets' id=target_id %}"><span class="fa fa-angle-left text-body"></span></a>
      <a href="{% url 'targets' id=target_id %}">Target {{ target_id }}: {{ target.name }}</a>
    </li>
    <li class="breadcrumb-item active">Light Curve Viewer</li>
  </ol>
</nav>

<!-- Mode Toggle -->
<div class="control-panel">
  <h5 class="mb-3">Display Mode</h5>
  <div class="btn-group">
    <button onclick="switchMode('magnitude')" class="btn btn-sm {% if data_mode == 'magnitude' %}btn-primary{% else %}btn-outline-primary{% endif %}">
      <i class="fa fa-star"></i> Magnitudes
    </button>
    <button onclick="switchMode('flux')" class="btn btn-sm {% if data_mode == 'flux' %}btn-primary{% else %}btn-outline-primary{% endif %}">
      <i class="fa fa-line-chart"></i> TESS Flux
    </button>
  </div>
</div>

<!-- Loading indicator -->
<div id="loading-indicator" class="mt-3" style="display: none;">
  <div class="d-flex align-items-center mb-2">
    <strong>Loading lightcurve data...</strong>
    <div class="spinner-border spinner-border-sm ms-auto" role="status" aria-hidden="true"></div>
  </div>
  <div class="progress" style="height: 25px;">
    <div class="progress-bar progress-bar-striped progress-bar-animated bg-info"
         role="progressbar"
         style="width: 100%"
         aria-valuenow="100"
         aria-valuemin="0"
         aria-valuemax="100">
      <span id="loading-status">Fetching data from server...</span>
    </div>
  </div>
</div>

<!-- No data warning (hidden initially) -->
<div id="no-data-warning" class="alert alert-warning mt-3" style="display: none;">
  No lightcurve data available for <span id="no-data-mode"></span> mode.
  <span id="no-data-hint"></span>
</div>

<!-- Error message (hidden initially) -->
<div id="error-message" class="alert alert-danger mt-3" style="display: none;">
  <strong>Error loading data:</strong> <span id="error-text"></span>
</div>

<!-- Control Panel -->
<div class="control-panel" id="control-panel" style="display: none;">
  <h5 class="mb-3">Data Sources</h5>

  <div id="source-controls">
    <!-- Populated by JavaScript -->
  </div>

  <div class="mt-3">
    <button class="btn btn-sm btn-outline-primary me-2" onclick="resetOffsets()">
      <i class="fa fa-refresh"></i> Reset Controls
    </button>
    <button class="btn btn-sm btn-outline-primary me-2" onclick="enableAll()">
      <i class="fa fa-check-square-o"></i> Enable All
    </button>
    <button class="btn btn-sm btn-outline-primary" onclick="disableAll()">
      <i class="fa fa-square-o"></i> Disable All
    </button>
  </div>
</div>

<!-- Phase Folding Panel -->
<div class="control-panel mt-3" id="phase-panel" style="display: none;">
  <h5 class="mb-3">Phase Folding</h5>

  <div class="row g-2 align-items-center">
    <div class="col-auto">
      <label for="period-input" class="col-form-label col-form-label-sm">Period (days):</label>
    </div>
    <div class="col-auto">
      <input type="number" class="form-control form-control-sm" id="period-input"
             style="width: 120px;" step="0.001" min="0" placeholder="0 = off"
             onchange="updatePhaseFolding()">
    </div>
    <div class="col-auto">
      <label for="epoch-input" class="col-form-label col-form-label-sm">T₀ (MJD):</label>
    </div>
    <div class="col-auto">
      <input type="number" class="form-control form-control-sm" id="epoch-input"
             style="width: 120px;" step="0.001" value="0" placeholder="0"
             onchange="updatePhaseFolding()">
    </div>
    <div class="col-auto">
      <button class="btn btn-sm btn-outline-secondary" onclick="clearPhaseFolding()">
        <i class="fa fa-times"></i> Clear
      </button>
    </div>
    <div class="col-auto">
      <button class="btn btn-sm btn-primary" onclick="fitPeriod()" id="fit-period-btn">
        <i class="fa fa-calculator"></i> Fit Period
      </button>
    </div>
    <div class="col-auto">
      <button class="btn btn-sm btn-outline-secondary" onclick="multiplyPeriod()" title="Multiply period by 2">
        <i class="fa fa-arrow-up"></i> ×2
      </button>
    </div>
    <div class="col-auto">
      <button class="btn btn-sm btn-outline-secondary" onclick="dividePeriod()" title="Divide period by 2">
        <i class="fa fa-arrow-down"></i> ÷2
      </button>
    </div>
  </div>

  <div class="row g-2 align-items-center mt-2">
    <div class="col-auto">
      <label class="col-form-label col-form-label-sm text-muted">Period Search Range:</label>
    </div>
    <div class="col-auto">
      <label for="period-min-input" class="col-form-label col-form-label-sm">Min:</label>
    </div>
    <div class="col-auto">
      <input type="number" class="form-control form-control-sm" id="period-min-input"
             style="width: 100px;" step="0.01" min="0.01" value="0.1" placeholder="0.1">
    </div>
    <div class="col-auto">
      <label for="period-max-input" class="col-form-label col-form-label-sm">Max:</label>
    </div>
    <div class="col-auto">
      <input type="number" class="form-control form-control-sm" id="period-max-input"
             style="width: 100px;" step="0.1" min="0.1" value="100" placeholder="100">
    </div>
    <div class="col-auto">
      <small class="text-muted">days</small>
    </div>
  </div>

  <div class="mt-2">
    <small class="text-muted">
      Set period to enable phase folding. Phase range: -0.6 to 1.6 with wrapped data.
      Use "Fit Period" to automatically find the best period using visible data sources and error filters.
    </small>
  </div>
</div>

<!-- Plot Container -->
<div id="plotly-container" style="width: 100%; height: 600px; display: none;"></div>

<script>
// Light curve data (loaded asynchronously)
let lightcurveData = [];

// Data mode constants
let dataMode = "{{ data_mode }}";  // 'magnitude' or 'flux'
let isMagnitudeMode = dataMode === 'magnitude';

// Track state of each series
const seriesState = {};

// Track whether plot has been initialized
let plotInitialized = false;

// Phase folding parameters
let phasePeriod = 0;  // Period in days (0 = disabled)
let phaseEpoch = 0;   // T0 in MJD

// Cache for phase-folded data (key: seriesIndex-period-epoch-mode)
const phaseDataCache = {};

// Track data loading state
let dataLoaded = false;

// Convert MJD to JavaScript Date object
// MJD 0 = November 17, 1858, 00:00 UTC
// JavaScript uses milliseconds since January 1, 1970, 00:00 UTC
function mjdToDate(mjd) {
    // Days between Nov 17, 1858 and Jan 1, 1970 = 40587 days
    const daysSinceEpoch = mjd - 40587.0;
    const milliseconds = daysSinceEpoch * 86400000; // 86400000 ms per day
    return new Date(milliseconds);
}

// Convert MJD array to Date objects (faster than ISO strings)
// Only computed when needed, cached in series data
function ensureDatetimes(series) {
    if (!series._datetimes) {
        series._datetimes = series.mjd.map(mjd => mjdToDate(mjd));
    }
    return series._datetimes;
}

// Initialize series state and create controls
function initializeControls() {
    const container = document.getElementById('source-controls');
    container.innerHTML = '';

    lightcurveData.forEach((series, index) => {
        // Initialize state
        seriesState[index] = {
            visible: true,
            offset: 0,
            markerSize: 4,
            maxError: null,  // null = no filtering
            color: series.color,
            defaultColor: series.color,
            data: series
        };

        // Create control element
        const control = document.createElement('div');
        control.className = 'source-control';

        // Build HTML with conditional max error control (magnitude mode only)
        let html = `
            <div class="source-color" style="background-color: ${series.color};" id="color-display-${index}">
                <input type="color" class="color-input" id="color-${index}"
                       value="${series.color}" onchange="updateColor(${index})">
            </div>
            <div class="source-label">${series.label}</div>
            <div class="source-info" id="info-${index}">${series.n_points} points</div>
            <span class="control-label">Offset:</span>
            <input type="number" class="form-control form-control-sm offset-control"
                   id="offset-${index}" value="0" step="0.1"
                   onchange="updateOffset(${index})">
        `;

        // Add max error control only in magnitude mode
        if (isMagnitudeMode) {
            html += `
            <span class="control-label">Max Err:</span>
            <input type="number" class="form-control form-control-sm maxerr-control"
                   id="maxerr-${index}" placeholder="∞" step="0.01" min="0"
                   onchange="updateMaxError(${index})">
            `;
        }

        html += `
            <span class="control-label">Size:</span>
            <input type="number" class="form-control form-control-sm size-control"
                   id="size-${index}" value="4" step="0.5" min="0.5" max="20"
                   onchange="updateMarkerSize(${index})">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox"
                       id="toggle-${index}" checked
                       onchange="toggleSeries(${index})">
            </div>
        `;

        control.innerHTML = html;
        container.appendChild(control);
    });
}

// Calculate phase from MJD
function calculatePhase(mjd, period, epoch) {
    return ((mjd - epoch) % period) / period;
}

// Prepare data for phase-folded display (with caching)
function preparePhaseData(series, seriesIndex, period, epoch) {
    // Create cache key from series index, period, epoch, and mode
    const cacheKey = `${seriesIndex}-${period.toFixed(10)}-${epoch.toFixed(10)}-${dataMode}`;

    // Check cache first
    if (phaseDataCache[cacheKey]) {
        return phaseDataCache[cacheKey];
    }

    const phases = [];
    const values = [];
    const errs = [];
    const mjds = [];
    const datetimes = [];

    // Use appropriate data keys based on mode
    const dataKey = isMagnitudeMode ? 'mag' : 'flux';
    const errKey = isMagnitudeMode ? 'magerr' : 'flux_err';

    // Convert MJD to datetime strings on demand (with caching)
    const seriesDatetimes = ensureDatetimes(series);

    // Calculate phases for all points
    for (let i = 0; i < series.mjd.length; i++) {
        const phase = calculatePhase(series.mjd[i], period, epoch);

        // Normalize phase to [0, 1)
        const normalizedPhase = phase >= 0 ? phase : phase + 1;

        phases.push(normalizedPhase);
        values.push(series[dataKey][i]);
        errs.push(series[errKey][i]);
        mjds.push(series.mjd[i]);
        datetimes.push(seriesDatetimes[i]);
    }

    // Wrap data to fill -0.6 to 1.6 range
    const wrappedPhases = [...phases];
    const wrappedValues = [...values];
    const wrappedErrs = [...errs];
    const wrappedMjds = [...mjds];
    const wrappedDatetimes = [...datetimes];

    // Add wrapped copies for phase > 0.4 at negative phases (for -0.6 to 0 range)
    for (let i = 0; i < phases.length; i++) {
        if (phases[i] >= 0.4) {
            wrappedPhases.push(phases[i] - 1);
            wrappedValues.push(values[i]);
            wrappedErrs.push(errs[i]);
            wrappedMjds.push(mjds[i]);
            wrappedDatetimes.push(datetimes[i]);
        }
    }

    // Add wrapped copies for phase < 0.6 at phase + 1 (for 1.0 to 1.6 range)
    for (let i = 0; i < phases.length; i++) {
        if (phases[i] < 0.6) {
            wrappedPhases.push(phases[i] + 1);
            wrappedValues.push(values[i]);
            wrappedErrs.push(errs[i]);
            wrappedMjds.push(mjds[i]);
            wrappedDatetimes.push(datetimes[i]);
        }
    }

    const result = {
        phases: wrappedPhases,
        values: wrappedValues,
        errs: wrappedErrs,
        mjds: wrappedMjds,
        datetimes: wrappedDatetimes
    };

    // Cache the result
    phaseDataCache[cacheKey] = result;

    return result;
}

// Update plot
function updatePlot() {
    const traces = [];
    const isPhaseFolded = phasePeriod > 0;

    // Determine value label and data keys based on mode
    const valueLabel = isMagnitudeMode ? 'Magnitude' : 'Normalized Flux';
    const dataKey = isMagnitudeMode ? 'mag' : 'flux';
    const errKey = isMagnitudeMode ? 'magerr' : 'flux_err';

    // Check if any series has >5000 points (use MJD mode for performance)
    const useMJDMode = !isPhaseFolded && lightcurveData.some(series => series.mjd.length > 5000);

    lightcurveData.forEach((series, index) => {
        const state = seriesState[index];
        if (!state.visible) return;

        let xData, yData, errData, customData, hoverTemplate;
        let totalPoints, filteredCount;

        if (isPhaseFolded) {
            // Phase-folded mode (with caching for performance)
            const phaseData = preparePhaseData(series, index, phasePeriod, phaseEpoch);
            totalPoints = phaseData.phases.length;

            // Filter and build arrays in a single pass (more efficient)
            xData = [];
            yData = [];
            errData = [];
            customData = [];

            const hasMaxErrorFilter = isMagnitudeMode && state.maxError !== null;

            for (let i = 0; i < totalPoints; i++) {
                if (!hasMaxErrorFilter || phaseData.errs[i] <= state.maxError) {
                    xData.push(phaseData.phases[i]);
                    yData.push(phaseData.values[i] + state.offset);
                    errData.push(phaseData.errs[i]);
                    customData.push([
                        phaseData.mjds[i],
                        phaseData.errs[i],
                        phaseData.phases[i]
                    ]);
                }
            }

            filteredCount = xData.length;

            hoverTemplate =
                '<b>%{fullData.name}</b><br>' +
                'Phase: %{customdata[2]:.4f}<br>' +
                'MJD: %{customdata[0]:.2f}<br>' +
                valueLabel + ': %{y:.3f} ± %{customdata[1]:.3f}<br>' +
                '<extra></extra>';
        } else {
            // Time mode
            totalPoints = series[dataKey].length;

            // Filter and build arrays in a single pass (more efficient)
            xData = [];
            yData = [];
            errData = [];
            customData = [];

            const hasMaxErrorFilter = isMagnitudeMode && state.maxError !== null;

            if (useMJDMode) {
                // Use MJD directly (no datetime conversion needed)
                for (let i = 0; i < totalPoints; i++) {
                    if (!hasMaxErrorFilter || series[errKey][i] <= state.maxError) {
                        xData.push(series.mjd[i]);
                        yData.push(series[dataKey][i] + state.offset);
                        errData.push(series[errKey][i]);
                        customData.push([series.mjd[i], series[errKey][i]]);
                    }
                }

                hoverTemplate =
                    '<b>%{fullData.name}</b><br>' +
                    'MJD: %{x:.2f}<br>' +
                    valueLabel + ': %{y:.3f} ± %{customdata[1]:.3f}<br>' +
                    '<extra></extra>';
            } else {
                // Convert MJD to dates (computed once and cached)
                const datetimes = ensureDatetimes(series);

                for (let i = 0; i < totalPoints; i++) {
                    if (!hasMaxErrorFilter || series[errKey][i] <= state.maxError) {
                        xData.push(datetimes[i]);
                        yData.push(series[dataKey][i] + state.offset);
                        errData.push(series[errKey][i]);
                        customData.push([series.mjd[i], series[errKey][i]]);
                    }
                }

                hoverTemplate =
                    '<b>%{fullData.name}</b><br>' +
                    'Time: %{x}<br>' +
                    'MJD: %{customdata[0]:.2f}<br>' +
                    valueLabel + ': %{y:.3f} ± %{customdata[1]:.3f}<br>' +
                    '<extra></extra>';
            }

            filteredCount = xData.length;
        }

        // Update point count display
        const infoElement = document.getElementById(`info-${index}`);
        if (infoElement) {
            if (filteredCount < totalPoints) {
                infoElement.textContent = `${filteredCount}/${totalPoints} points`;
            } else {
                infoElement.textContent = `${totalPoints} points`;
            }
        }

        // Use WebGL rendering (scattergl) for large datasets (>1000 points)
        const useWebGL = xData.length > 1000;

        traces.push({
            x: xData,
            y: yData,
            customdata: customData,
            error_y: {
                type: 'data',
                array: errData,
                visible: true,
                color: state.color,
                thickness: 1,
                width: 0
            },
            mode: 'markers',
            type: useWebGL ? 'scattergl' : 'scatter',
            name: series.label,
            marker: {
                color: state.color,
                size: state.markerSize,
            },
            hovertemplate: hoverTemplate,
        });
    });

    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        displaylogo: false,
    };

    // Determine plot title based on mode
    const titleText = isMagnitudeMode
        ? '{{ target.name }} - Multi-Survey Light Curve'
        : '{{ target.name }} - TESS Flux Light Curve';

    // Determine y-axis label based on mode
    const yAxisTitle = isMagnitudeMode ? 'Magnitude' : 'Normalized Flux';

    // Use newPlot for initial render, react for updates to preserve zoom state
    if (!plotInitialized) {
        const layout = {
            title: {
                text: titleText,
                font: { size: 18 }
            },
            xaxis: isPhaseFolded ? {
                title: `Phase (P = ${phasePeriod.toFixed(6)} days, T₀ = ${phaseEpoch.toFixed(2)} MJD)`,
                gridcolor: '#e0e0e0',
                range: [-0.6, 1.6],
                zeroline: false,
            } : {
                title: useMJDMode ? 'Modified Julian Date (MJD)' : 'Universal Time (UT)',
                gridcolor: '#e0e0e0',
                zeroline: false,
            },
            yaxis: {
                title: yAxisTitle,
                autorange: isMagnitudeMode ? 'reversed' : true,  // Inverted for magnitudes, normal for flux
                gridcolor: '#e0e0e0',
                zeroline: false,
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                orientation: 'v',
                yanchor: 'top',
                y: 1,
                xanchor: 'right',
                x: 1
            },
            margin: {
                l: 60,
                r: 20,
                t: 60,
                b: 60
            },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            shapes: isPhaseFolded ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                },
                {
                    type: 'line',
                    x0: 1,
                    y0: 0,
                    x1: 1,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                }
            ] : (!isMagnitudeMode ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 1,
                    x1: 1,
                    y1: 1,
                    xref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash',
                        opacity: 0.5
                    }
                }
            ] : [])
        };
        Plotly.newPlot('plotly-container', traces, layout, config);
        plotInitialized = true;
    } else {
        // Get current axis ranges to preserve zoom
        const plotDiv = document.getElementById('plotly-container');
        const currentLayout = plotDiv.layout;

        const layout = {
            title: {
                text: titleText,
                font: { size: 18 }
            },
            xaxis: isPhaseFolded ? {
                title: `Phase (P = ${phasePeriod.toFixed(6)} days, T₀ = ${phaseEpoch.toFixed(2)} MJD)`,
                gridcolor: '#e0e0e0',
                range: [-0.6, 1.6],
                zeroline: false,
            } : {
                title: useMJDMode ? 'Modified Julian Date (MJD)' : 'Universal Time (UT)',
                gridcolor: '#e0e0e0',
                // Preserve current range if it exists (only in time mode)
                range: currentLayout.xaxis.range,
                autorange: currentLayout.xaxis.autorange,
                zeroline: false,
            },
            yaxis: {
                title: yAxisTitle,
                gridcolor: '#e0e0e0',
                // Preserve current range if it exists
                range: currentLayout.yaxis.range,
                autorange: currentLayout.yaxis.autorange,
                zeroline: false,
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                orientation: 'v',
                yanchor: 'top',
                y: 1,
                xanchor: 'right',
                x: 1
            },
            margin: {
                l: 60,
                r: 20,
                t: 60,
                b: 60
            },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            shapes: isPhaseFolded ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                },
                {
                    type: 'line',
                    x0: 1,
                    y0: 0,
                    x1: 1,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                }
            ] : (!isMagnitudeMode ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 1,
                    x1: 1,
                    y1: 1,
                    xref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash',
                        opacity: 0.5
                    }
                }
            ] : [])
        };

        // Plotly.react updates the plot while preserving zoom/pan state
        Plotly.react('plotly-container', traces, layout, config);
    }
}

// Update phase folding parameters and redraw plot
function updatePhaseFolding() {
    const periodInput = document.getElementById('period-input');
    const epochInput = document.getElementById('epoch-input');

    phasePeriod = parseFloat(periodInput.value) || 0;
    phaseEpoch = parseFloat(epochInput.value) || 0;

    // Force reinitialize plot when switching modes
    if (plotInitialized) {
        plotInitialized = false;
        updatePlot();
        plotInitialized = true;
    }
}

// Clear phase folding
function clearPhaseFolding() {
    document.getElementById('period-input').value = '';
    document.getElementById('epoch-input').value = '0';
    phasePeriod = 0;
    phaseEpoch = 0;

    // Force reinitialize plot
    if (plotInitialized) {
        plotInitialized = false;
        updatePlot();
        plotInitialized = true;
    }
}

// Multiply period by 2
function multiplyPeriod() {
    const periodInput = document.getElementById('period-input');
    const currentPeriod = parseFloat(periodInput.value) || 0;

    if (currentPeriod <= 0) {
        alert('No period set! Set a period first or use "Fit Period".');
        return;
    }

    const newPeriod = currentPeriod * 2;
    periodInput.value = newPeriod.toFixed(6);
    phasePeriod = newPeriod;

    updatePhaseFolding();
}

// Divide period by 2
function dividePeriod() {
    const periodInput = document.getElementById('period-input');
    const currentPeriod = parseFloat(periodInput.value) || 0;

    if (currentPeriod <= 0) {
        alert('No period set! Set a period first or use "Fit Period".');
        return;
    }

    const newPeriod = currentPeriod / 2;
    periodInput.value = newPeriod.toFixed(6);
    phasePeriod = newPeriod;

    updatePhaseFolding();
}

// Get CSRF token from cookies
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Fit period using Lomb-Scargle multiband periodogram
function fitPeriod() {
    // Check if data is loaded
    if (!dataLoaded) {
        alert('Data is still loading. Please wait...');
        return;
    }

    // Collect visible series data with max error filtering applied
    const visibleSeries = [];
    const dataKey = isMagnitudeMode ? 'mag' : 'flux';
    const errKey = isMagnitudeMode ? 'magerr' : 'flux_err';

    lightcurveData.forEach((series, index) => {
        const state = seriesState[index];
        if (!state.visible) return;

        // Apply max error filter if set (magnitude mode only)
        let filteredIndices = [...Array(series[dataKey].length).keys()];
        if (isMagnitudeMode && state.maxError !== null) {
            filteredIndices = filteredIndices.filter(i => series[errKey][i] <= state.maxError);
        }

        // Only include series if we have data points after filtering
        if (filteredIndices.length === 0) return;

        // Collect filtered data
        const filteredMjd = filteredIndices.map(i => series.mjd[i]);
        const filteredValues = filteredIndices.map(i => series[dataKey][i]);
        const filteredErrors = filteredIndices.map(i => series[errKey][i]);

        visibleSeries.push({
            mjd: filteredMjd,
            values: filteredValues,
            errors: filteredErrors,
            label: series.label
        });
    });

    if (visibleSeries.length === 0) {
        alert('No visible series to fit! Please enable at least one data source with valid data points.');
        return;
    }

    // Get period search range
    const periodMin = parseFloat(document.getElementById('period-min-input').value) || 0.1;
    const periodMax = parseFloat(document.getElementById('period-max-input').value) || 100;

    if (periodMin <= 0 || periodMax <= periodMin) {
        alert('Invalid period range! Minimum must be positive and less than maximum.');
        return;
    }

    // Disable button and show loading state
    const btn = document.getElementById('fit-period-btn');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Fitting...';

    // Make AJAX request
    fetch(`/targets/{{ target_id }}/fit_period/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            series: visibleSeries,
            period_min: periodMin,
            period_max: periodMax
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(err.error || 'Server error');
            });
        }
        return response.json();
    })
    .then(data => {
        // Update period and epoch inputs
        document.getElementById('period-input').value = data.period.toFixed(6);
        document.getElementById('epoch-input').value = data.epoch.toFixed(2);

        // Update global variables
        phasePeriod = data.period;
        phaseEpoch = data.epoch;

        // Show results
        let message = `Period fit successful!\n\n` +
            `Best period: ${data.period.toFixed(6)} days\n` +
            `Epoch (T₀): ${data.epoch.toFixed(2)} MJD\n` +
            `Power: ${data.power.toFixed(4)}\n`;

        if (data.fap !== undefined) {
            const fapStr = data.fap < 0.0001 ? data.fap.toExponential(2) : data.fap.toFixed(4);
            message += `False Alarm Prob: ${fapStr}\n`;
        } else {
            message += `False Alarm Prob: N/A (multiband fit)\n`;
        }

        message += `\nSearch range: ${data.period_min.toFixed(2)} - ${data.period_max.toFixed(2)} days\n`;
        message += `Fitted ${data.n_points} points from ${data.n_series} series.`;

        alert(message);

        // Update plot with phase folding
        updatePhaseFolding();
    })
    .catch(error => {
        console.error('Error fitting period:', error);
        alert(`Error fitting period: ${error.message}\n\nSee console for details.`);
    })
    .finally(() => {
        // Re-enable button
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    });
}

// Toggle series visibility
function toggleSeries(index) {
    const checkbox = document.getElementById(`toggle-${index}`);
    seriesState[index].visible = checkbox.checked;
    updatePlot();
}

// Update offset for a series
function updateOffset(index) {
    const input = document.getElementById(`offset-${index}`);
    seriesState[index].offset = parseFloat(input.value) || 0;
    updatePlot();
}

// Update marker size for a series
function updateMarkerSize(index) {
    const input = document.getElementById(`size-${index}`);
    seriesState[index].markerSize = parseFloat(input.value) || 4;
    updatePlot();
}

// Update maximum error filter for a series
function updateMaxError(index) {
    const input = document.getElementById(`maxerr-${index}`);
    const value = parseFloat(input.value);
    seriesState[index].maxError = (value > 0) ? value : null;  // null = no filtering
    updatePlot();
}

// Update color for a series
function updateColor(index) {
    const input = document.getElementById(`color-${index}`);
    const colorDisplay = document.getElementById(`color-display-${index}`);
    seriesState[index].color = input.value;
    colorDisplay.style.backgroundColor = input.value;
    updatePlot();
}

// Reset all offsets, marker sizes, colors, and max error
function resetOffsets() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].offset = 0;
        seriesState[index].markerSize = 4;
        seriesState[index].maxError = null;
        seriesState[index].color = seriesState[index].defaultColor;
        document.getElementById(`offset-${index}`).value = 0;
        document.getElementById(`size-${index}`).value = 4;
        document.getElementById(`color-${index}`).value = seriesState[index].defaultColor;
        document.getElementById(`color-display-${index}`).style.backgroundColor = seriesState[index].defaultColor;

        // Reset max error if it exists (magnitude mode only)
        const maxErrInput = document.getElementById(`maxerr-${index}`);
        if (maxErrInput) {
            maxErrInput.value = '';
        }
    });
    updatePlot();
}

// Enable all series
function enableAll() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].visible = true;
        document.getElementById(`toggle-${index}`).checked = true;
    });
    updatePlot();
}

// Disable all series
function disableAll() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].visible = false;
        document.getElementById(`toggle-${index}`).checked = false;
    });
    updatePlot();
}

// Switch display mode while preserving period/epoch
function switchMode(newMode) {
    // Get current period and epoch values
    const periodInput = document.getElementById('period-input');
    const epochInput = document.getElementById('epoch-input');

    const period = periodInput.value;
    const epoch = epochInput.value;

    // Build URL with mode and optional period/epoch parameters
    let url = `?mode=${newMode}`;

    if (period) {
        url += `&period=${encodeURIComponent(period)}`;
    }

    if (epoch) {
        url += `&epoch=${encodeURIComponent(epoch)}`;
    }

    // Update URL without reloading (for better UX and browser history)
    window.history.pushState({mode: newMode}, '', url);

    // Update mode toggle button states
    document.querySelectorAll('.control-panel .btn-group button').forEach(btn => {
        if (btn.textContent.includes('Magnitudes')) {
            if (newMode === 'magnitude') {
                btn.classList.remove('btn-outline-primary');
                btn.classList.add('btn-primary');
            } else {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline-primary');
            }
        } else if (btn.textContent.includes('TESS Flux')) {
            if (newMode === 'flux') {
                btn.classList.remove('btn-outline-primary');
                btn.classList.add('btn-primary');
            } else {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline-primary');
            }
        }
    });

    // Reset plot state
    plotInitialized = false;

    // Reload data for new mode
    loadLightcurveData();
}

// Get URL parameter by name
function getUrlParameter(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    const results = regex.exec(location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
}

// Update loading status text
function updateLoadingStatus(message) {
    const statusElement = document.getElementById('loading-status');
    if (statusElement) {
        statusElement.textContent = message;
    }
}

// Load lightcurve data asynchronously
function loadLightcurveData() {
    // Get mode from URL or use default
    const mode = getUrlParameter('mode') || '{{ data_mode }}';
    const modeLabel = mode === 'flux' ? 'TESS flux' : 'magnitude';

    // Show loading indicator
    document.getElementById('loading-indicator').style.display = 'block';
    document.getElementById('no-data-warning').style.display = 'none';
    document.getElementById('error-message').style.display = 'none';
    document.getElementById('control-panel').style.display = 'none';
    document.getElementById('phase-panel').style.display = 'none';

    updateLoadingStatus(`Requesting ${modeLabel} data from server...`);

    // Make AJAX request to load data
    const startTime = Date.now();
    fetch(`/targets/{{ target_id }}/lightcurve_data/?mode=${mode}`)
        .then(response => {
            updateLoadingStatus('Receiving data...');

            if (!response.ok) {
                return response.json().then(err => {
                    throw new Error(err.error || 'Server error');
                });
            }
            return response.json();
        })
        .then(result => {
            updateLoadingStatus('Processing lightcurve data...');

            // Small delay to show the processing message
            return new Promise(resolve => {
                setTimeout(() => resolve(result), 100);
            });
        })
        .then(result => {
            // Hide loading indicator
            document.getElementById('loading-indicator').style.display = 'none';

            // Update global variables
            lightcurveData = result.data;
            dataMode = result.mode;
            isMagnitudeMode = dataMode === 'magnitude';
            dataLoaded = true;

            const loadTime = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log(`Loaded ${result.data.length} series in ${loadTime}s`);

            if (result.no_data) {
                // Show no-data warning
                document.getElementById('no-data-warning').style.display = 'block';
                document.getElementById('no-data-mode').textContent = dataMode;
                if (dataMode === 'flux') {
                    document.getElementById('no-data-hint').textContent = 'Try acquiring TESS data first.';
                } else {
                    document.getElementById('no-data-hint').textContent = '';
                }
            } else {
                // Show controls, plot container, and initialize
                document.getElementById('control-panel').style.display = 'block';
                document.getElementById('phase-panel').style.display = 'block';
                document.getElementById('plotly-container').style.display = 'block';

                // Restore period and epoch from URL parameters if present
                const urlPeriod = getUrlParameter('period');
                const urlEpoch = getUrlParameter('epoch');

                if (urlPeriod) {
                    document.getElementById('period-input').value = urlPeriod;
                    phasePeriod = parseFloat(urlPeriod) || 0;
                }

                if (urlEpoch) {
                    document.getElementById('epoch-input').value = urlEpoch;
                    phaseEpoch = parseFloat(urlEpoch) || 0;
                }

                updateLoadingStatus('Initializing visualization...');

                console.log(`before initializeControls`);

                // Initialize controls and plot
                initializeControls();
                console.log(`before updatePlot`);
                updatePlot();
                console.log(`after updatePlot`);
            }
        })
        .catch(error => {
            console.error('Error loading lightcurve data:', error);

            // Hide loading indicator
            document.getElementById('loading-indicator').style.display = 'none';

            // Show error message
            document.getElementById('error-message').style.display = 'block';
            document.getElementById('error-text').textContent = error.message;
        });
}

// Handle browser back/forward buttons
window.addEventListener('popstate', function(event) {
    // Reset plot state
    plotInitialized = false;

    // Reload data for current URL
    loadLightcurveData();
});

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadLightcurveData();
});
</script>

{% endblock %}
