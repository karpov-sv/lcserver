{% extends "template.html" %}

{% load filters %}

{% block ptitle %}Light Curve : Target {{ target_id }} : LCServer{% endblock %}

{% block title %}Interactive Light Curve Viewer{% endblock %}

{% block head %}
<!-- Plotly.js -->
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>

<style>
.control-panel {
    background-color: var(--bs-light);
    border: 1px solid var(--bs-border-color);
    border-radius: 0.375rem;
    padding: 1rem;
    margin-bottom: 1rem;
}

.source-control {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    margin-bottom: 0.25rem;
    border-radius: 0.25rem;
    background-color: var(--bs-body-bg);
}

.source-control:hover {
    background-color: var(--bs-secondary-bg);
}

.source-color {
    width: 30px;
    height: 30px;
    border-radius: 3px;
    margin-right: 0.5rem;
    border: 1px solid var(--bs-border-color);
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.color-input {
    position: absolute;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}

.source-label {
    flex: 1;
    margin-right: 0.5rem;
    font-weight: 500;
}

.source-info {
    color: var(--bs-secondary-color);
    font-size: 0.875rem;
    margin-right: 1rem;
}

.offset-control {
    width: 80px;
    margin-right: 0.5rem;
}

.size-control {
    width: 60px;
    margin-right: 0.5rem;
}

.control-label {
    font-size: 0.875rem;
    color: var(--bs-secondary-color);
    margin-right: 0.5rem;
}
</style>
{% endblock %}

{% block content %}

<!-- Breadcrumb -->
<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    <li class="breadcrumb-item">
      <a href="{% url 'targets' id=target_id %}"><span class="fa fa-angle-left text-body"></span></a>
      <a href="{% url 'targets' id=target_id %}">Target {{ target_id }}: {{ target.name }}</a>
    </li>
    <li class="breadcrumb-item active">Light Curve Viewer</li>
  </ol>
</nav>

<!-- Mode Toggle -->
<div class="control-panel">
  <h5 class="mb-3">Display Mode</h5>
  <div class="btn-group">
    <a href="?mode=magnitude" class="btn btn-sm {% if data_mode == 'magnitude' %}btn-primary{% else %}btn-outline-primary{% endif %}">
      <i class="fa fa-star"></i> Magnitudes
    </a>
    <a href="?mode=flux" class="btn btn-sm {% if data_mode == 'flux' %}btn-primary{% else %}btn-outline-primary{% endif %}">
      <i class="fa fa-line-chart"></i> TESS Flux
    </a>
  </div>
</div>

{% if no_data %}
<div class="alert alert-warning mt-3">
  No lightcurve data available for {{ data_mode }} mode.
  {% if data_mode == 'flux' %}Try acquiring TESS data first.{% endif %}
</div>
{% endif %}

<!-- Control Panel -->
<div class="control-panel">
  <h5 class="mb-3">Data Sources</h5>

  <div id="source-controls">
    <!-- Populated by JavaScript -->
  </div>

  <div class="mt-3">
    <button class="btn btn-sm btn-outline-primary me-2" onclick="resetOffsets()">
      <i class="fa fa-refresh"></i> Reset Controls
    </button>
    <button class="btn btn-sm btn-outline-primary me-2" onclick="enableAll()">
      <i class="fa fa-check-square-o"></i> Enable All
    </button>
    <button class="btn btn-sm btn-outline-primary" onclick="disableAll()">
      <i class="fa fa-square-o"></i> Disable All
    </button>
  </div>
</div>

<!-- Phase Folding Panel -->
<div class="control-panel mt-3">
  <h5 class="mb-3">Phase Folding</h5>

  <div class="row g-2 align-items-center">
    <div class="col-auto">
      <label for="period-input" class="col-form-label col-form-label-sm">Period (days):</label>
    </div>
    <div class="col-auto">
      <input type="number" class="form-control form-control-sm" id="period-input"
             style="width: 120px;" step="0.001" min="0" placeholder="0 = off"
             onchange="updatePhaseFolding()">
    </div>
    <div class="col-auto">
      <label for="epoch-input" class="col-form-label col-form-label-sm">T₀ (MJD):</label>
    </div>
    <div class="col-auto">
      <input type="number" class="form-control form-control-sm" id="epoch-input"
             style="width: 120px;" step="0.001" value="0" placeholder="0"
             onchange="updatePhaseFolding()">
    </div>
    <div class="col-auto">
      <button class="btn btn-sm btn-outline-secondary" onclick="clearPhaseFolding()">
        <i class="fa fa-times"></i> Clear
      </button>
    </div>
  </div>

  <div class="mt-2">
    <small class="text-muted">
      Set period to enable phase folding. Phase range: -0.6 to 1.6 with wrapped data.
    </small>
  </div>
</div>

<!-- Plot Container -->
<div id="plotly-container" style="width: 100%; height: 600px;"></div>

<script>
// Parse light curve data from Django context
const lightcurveData = {{ lightcurve_data|safe }};

// Data mode constants
const dataMode = "{{ data_mode }}";  // 'magnitude' or 'flux'
const isMagnitudeMode = dataMode === 'magnitude';

// Track state of each series
const seriesState = {};

// Track whether plot has been initialized
let plotInitialized = false;

// Phase folding parameters
let phasePeriod = 0;  // Period in days (0 = disabled)
let phaseEpoch = 0;   // T0 in MJD

// Initialize series state and create controls
function initializeControls() {
    const container = document.getElementById('source-controls');
    container.innerHTML = '';

    lightcurveData.forEach((series, index) => {
        // Initialize state
        seriesState[index] = {
            visible: true,
            offset: 0,
            markerSize: 4,
            color: series.color,
            defaultColor: series.color,
            data: series
        };

        // Create control element
        const control = document.createElement('div');
        control.className = 'source-control';
        control.innerHTML = `
            <div class="source-color" style="background-color: ${series.color};" id="color-display-${index}">
                <input type="color" class="color-input" id="color-${index}"
                       value="${series.color}" onchange="updateColor(${index})">
            </div>
            <div class="source-label">${series.label}</div>
            <div class="source-info">${series.n_points} points</div>
            <span class="control-label">Offset:</span>
            <input type="number" class="form-control form-control-sm offset-control"
                   id="offset-${index}" value="0" step="0.1"
                   onchange="updateOffset(${index})">
            <span class="control-label">Size:</span>
            <input type="number" class="form-control form-control-sm size-control"
                   id="size-${index}" value="4" step="0.5" min="0.5" max="20"
                   onchange="updateMarkerSize(${index})">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox"
                       id="toggle-${index}" checked
                       onchange="toggleSeries(${index})">
            </div>
        `;
        container.appendChild(control);
    });
}

// Calculate phase from MJD
function calculatePhase(mjd, period, epoch) {
    return ((mjd - epoch) % period) / period;
}

// Prepare data for phase-folded display
function preparePhaseData(series, period, epoch) {
    const phases = [];
    const values = [];
    const errs = [];
    const mjds = [];
    const datetimes = [];

    // Use appropriate data keys based on mode
    const dataKey = isMagnitudeMode ? 'mag' : 'flux';
    const errKey = isMagnitudeMode ? 'magerr' : 'flux_err';

    // Calculate phases for all points
    for (let i = 0; i < series.mjd.length; i++) {
        const phase = calculatePhase(series.mjd[i], period, epoch);

        // Normalize phase to [0, 1)
        const normalizedPhase = phase >= 0 ? phase : phase + 1;

        phases.push(normalizedPhase);
        values.push(series[dataKey][i]);
        errs.push(series[errKey][i]);
        mjds.push(series.mjd[i]);
        datetimes.push(series.datetime[i]);
    }

    // Wrap data to fill -0.6 to 1.6 range
    const wrappedPhases = [...phases];
    const wrappedValues = [...values];
    const wrappedErrs = [...errs];
    const wrappedMjds = [...mjds];
    const wrappedDatetimes = [...datetimes];

    // Add wrapped copies for phase > 0.4 at negative phases (for -0.6 to 0 range)
    for (let i = 0; i < phases.length; i++) {
        if (phases[i] >= 0.4) {
            wrappedPhases.push(phases[i] - 1);
            wrappedValues.push(values[i]);
            wrappedErrs.push(errs[i]);
            wrappedMjds.push(mjds[i]);
            wrappedDatetimes.push(datetimes[i]);
        }
    }

    // Add wrapped copies for phase < 0.6 at phase + 1 (for 1.0 to 1.6 range)
    for (let i = 0; i < phases.length; i++) {
        if (phases[i] < 0.6) {
            wrappedPhases.push(phases[i] + 1);
            wrappedValues.push(values[i]);
            wrappedErrs.push(errs[i]);
            wrappedMjds.push(mjds[i]);
            wrappedDatetimes.push(datetimes[i]);
        }
    }

    return {
        phases: wrappedPhases,
        values: wrappedValues,
        errs: wrappedErrs,
        mjds: wrappedMjds,
        datetimes: wrappedDatetimes
    };
}

// Update plot
function updatePlot() {
    const traces = [];
    const isPhaseFolded = phasePeriod > 0;

    // Determine value label and data keys based on mode
    const valueLabel = isMagnitudeMode ? 'Magnitude' : 'Normalized Flux';
    const dataKey = isMagnitudeMode ? 'mag' : 'flux';
    const errKey = isMagnitudeMode ? 'magerr' : 'flux_err';

    lightcurveData.forEach((series, index) => {
        const state = seriesState[index];
        if (!state.visible) return;

        let xData, yData, errData, customData, hoverTemplate;

        if (isPhaseFolded) {
            // Phase-folded mode
            const phaseData = preparePhaseData(series, phasePeriod, phaseEpoch);

            xData = phaseData.phases;
            yData = phaseData.values.map(v => v + state.offset);
            errData = phaseData.errs;
            customData = phaseData.mjds.map((mjd, i) => [
                mjd,
                phaseData.errs[i],
                phaseData.phases[i]
            ]);

            hoverTemplate =
                '<b>%{fullData.name}</b><br>' +
                'Phase: %{customdata[2]:.4f}<br>' +
                'MJD: %{customdata[0]:.2f}<br>' +
                valueLabel + ': %{y:.3f} ± %{customdata[1]:.3f}<br>' +
                '<extra></extra>';
        } else {
            // Time mode
            const values_with_offset = series[dataKey].map(v => v + state.offset);

            xData = series.datetime;
            yData = values_with_offset;
            errData = series[errKey];
            customData = series.mjd.map((mjd, i) => [mjd, series[errKey][i]]);

            hoverTemplate =
                '<b>%{fullData.name}</b><br>' +
                'Time: %{x}<br>' +
                'MJD: %{customdata[0]:.2f}<br>' +
                valueLabel + ': %{y:.3f} ± %{customdata[1]:.3f}<br>' +
                '<extra></extra>';
        }

        traces.push({
            x: xData,
            y: yData,
            customdata: customData,
            error_y: {
                type: 'data',
                array: errData,
                visible: true,
                color: state.color,
                thickness: 1,
                width: 0
            },
            mode: 'markers',
            type: 'scatter',
            name: series.label,
            marker: {
                color: state.color,
                size: state.markerSize,
            },
            hovertemplate: hoverTemplate,
        });
    });

    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        displaylogo: false,
    };

    // Determine plot title based on mode
    const titleText = isMagnitudeMode
        ? '{{ target.name }} - Multi-Survey Light Curve'
        : '{{ target.name }} - TESS Flux Light Curve';

    // Determine y-axis label based on mode
    const yAxisTitle = isMagnitudeMode ? 'Magnitude' : 'Normalized Flux';

    // Use newPlot for initial render, react for updates to preserve zoom state
    if (!plotInitialized) {
        const layout = {
            title: {
                text: titleText,
                font: { size: 18 }
            },
            xaxis: isPhaseFolded ? {
                title: `Phase (P = ${phasePeriod.toFixed(6)} days, T₀ = ${phaseEpoch.toFixed(2)} MJD)`,
                gridcolor: '#e0e0e0',
                range: [-0.6, 1.6],
                zeroline: false,
            } : {
                title: 'Universal Time (UT)',
                gridcolor: '#e0e0e0',
                zeroline: false,
            },
            yaxis: {
                title: yAxisTitle,
                autorange: isMagnitudeMode ? 'reversed' : true,  // Inverted for magnitudes, normal for flux
                gridcolor: '#e0e0e0',
                zeroline: false,
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                orientation: 'v',
                yanchor: 'top',
                y: 1,
                xanchor: 'right',
                x: 1
            },
            margin: {
                l: 60,
                r: 20,
                t: 60,
                b: 60
            },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            shapes: isPhaseFolded ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                },
                {
                    type: 'line',
                    x0: 1,
                    y0: 0,
                    x1: 1,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                }
            ] : (!isMagnitudeMode ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 1,
                    x1: 1,
                    y1: 1,
                    xref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash',
                        opacity: 0.5
                    }
                }
            ] : [])
        };
        Plotly.newPlot('plotly-container', traces, layout, config);
        plotInitialized = true;
    } else {
        // Get current axis ranges to preserve zoom
        const plotDiv = document.getElementById('plotly-container');
        const currentLayout = plotDiv.layout;

        const layout = {
            title: {
                text: titleText,
                font: { size: 18 }
            },
            xaxis: isPhaseFolded ? {
                title: `Phase (P = ${phasePeriod.toFixed(6)} days, T₀ = ${phaseEpoch.toFixed(2)} MJD)`,
                gridcolor: '#e0e0e0',
                range: [-0.6, 1.6],
                zeroline: false,
            } : {
                title: 'Universal Time (UT)',
                gridcolor: '#e0e0e0',
                // Preserve current range if it exists (only in time mode)
                range: currentLayout.xaxis.range,
                autorange: currentLayout.xaxis.autorange,
                zeroline: false,
            },
            yaxis: {
                title: yAxisTitle,
                gridcolor: '#e0e0e0',
                // Preserve current range if it exists
                range: currentLayout.yaxis.range,
                autorange: currentLayout.yaxis.autorange,
                zeroline: false,
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                orientation: 'v',
                yanchor: 'top',
                y: 1,
                xanchor: 'right',
                x: 1
            },
            margin: {
                l: 60,
                r: 20,
                t: 60,
                b: 60
            },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            shapes: isPhaseFolded ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                },
                {
                    type: 'line',
                    x0: 1,
                    y0: 0,
                    x1: 1,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                }
            ] : (!isMagnitudeMode ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 1,
                    x1: 1,
                    y1: 1,
                    xref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash',
                        opacity: 0.5
                    }
                }
            ] : [])
        };

        // Plotly.react updates the plot while preserving zoom/pan state
        Plotly.react('plotly-container', traces, layout, config);
    }
}

// Update phase folding parameters and redraw plot
function updatePhaseFolding() {
    const periodInput = document.getElementById('period-input');
    const epochInput = document.getElementById('epoch-input');

    phasePeriod = parseFloat(periodInput.value) || 0;
    phaseEpoch = parseFloat(epochInput.value) || 0;

    // Force reinitialize plot when switching modes
    if (plotInitialized) {
        plotInitialized = false;
        updatePlot();
        plotInitialized = true;
    }
}

// Clear phase folding
function clearPhaseFolding() {
    document.getElementById('period-input').value = '';
    document.getElementById('epoch-input').value = '0';
    phasePeriod = 0;
    phaseEpoch = 0;

    // Force reinitialize plot
    if (plotInitialized) {
        plotInitialized = false;
        updatePlot();
        plotInitialized = true;
    }
}

// Toggle series visibility
function toggleSeries(index) {
    const checkbox = document.getElementById(`toggle-${index}`);
    seriesState[index].visible = checkbox.checked;
    updatePlot();
}

// Update offset for a series
function updateOffset(index) {
    const input = document.getElementById(`offset-${index}`);
    seriesState[index].offset = parseFloat(input.value) || 0;
    updatePlot();
}

// Update marker size for a series
function updateMarkerSize(index) {
    const input = document.getElementById(`size-${index}`);
    seriesState[index].markerSize = parseFloat(input.value) || 4;
    updatePlot();
}

// Update color for a series
function updateColor(index) {
    const input = document.getElementById(`color-${index}`);
    const colorDisplay = document.getElementById(`color-display-${index}`);
    seriesState[index].color = input.value;
    colorDisplay.style.backgroundColor = input.value;
    updatePlot();
}

// Reset all offsets, marker sizes, and colors
function resetOffsets() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].offset = 0;
        seriesState[index].markerSize = 4;
        seriesState[index].color = seriesState[index].defaultColor;
        document.getElementById(`offset-${index}`).value = 0;
        document.getElementById(`size-${index}`).value = 4;
        document.getElementById(`color-${index}`).value = seriesState[index].defaultColor;
        document.getElementById(`color-display-${index}`).style.backgroundColor = seriesState[index].defaultColor;
    });
    updatePlot();
}

// Enable all series
function enableAll() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].visible = true;
        document.getElementById(`toggle-${index}`).checked = true;
    });
    updatePlot();
}

// Disable all series
function disableAll() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].visible = false;
        document.getElementById(`toggle-${index}`).checked = false;
    });
    updatePlot();
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    initializeControls();
    updatePlot();
});
</script>

{% endblock %}
