{% extends "template.html" %}

{% load filters %}

{% block ptitle %}Light Curve : Target {{ target_id }} : LCServer{% endblock %}

{% block title %}Interactive Light Curve Viewer{% endblock %}

{% block head %}
<!-- Plotly.js -->
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>

<style>
.control-panel {
    background-color: var(--bs-light);
    border: 1px solid var(--bs-border-color);
    border-radius: 0.375rem;
    padding: 1rem;
    margin-bottom: 1rem;
}

.source-control {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    margin-bottom: 0.25rem;
    border-radius: 0.25rem;
    background-color: var(--bs-body-bg);
}

.source-control:hover {
    background-color: var(--bs-secondary-bg);
}

.source-color {
    width: 30px;
    height: 30px;
    border-radius: 3px;
    margin-right: 0.5rem;
    border: 1px solid var(--bs-border-color);
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.color-input {
    position: absolute;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}

.source-label {
    flex: 1;
    margin-right: 0.5rem;
    font-weight: 500;
}

.source-info {
    color: var(--bs-secondary-color);
    font-size: 0.875rem;
    margin-right: 1rem;
}

.offset-control {
    width: 80px;
    margin-right: 0.5rem;
}

.size-control {
    width: 60px;
    margin-right: 0.5rem;
}

.control-label {
    font-size: 0.875rem;
    color: var(--bs-secondary-color);
    margin-right: 0.5rem;
}
</style>
{% endblock %}

{% block content %}

<!-- Breadcrumb -->
<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    <li class="breadcrumb-item">
      <a href="{% url 'targets' id=target_id %}"><span class="fa fa-angle-left text-body"></span></a>
      <a href="{% url 'targets' id=target_id %}">Target {{ target_id }}: {{ target.name }}</a>
    </li>
    <li class="breadcrumb-item active">Light Curve Viewer</li>
  </ol>
</nav>

<!-- Mode Toggle -->
<div class="control-panel">
  <h5 class="mb-3">Display Mode</h5>
  <div class="btn-group">
    <button onclick="switchMode('magnitude')" class="btn btn-sm {% if data_mode == 'magnitude' %}btn-primary{% else %}btn-outline-primary{% endif %}">
      <i class="fa fa-star"></i> Magnitudes
    </button>
    <button onclick="switchMode('flux')" class="btn btn-sm {% if data_mode == 'flux' %}btn-primary{% else %}btn-outline-primary{% endif %}">
      <i class="fa fa-line-chart"></i> TESS Flux
    </button>
  </div>
</div>

<!-- Loading indicator -->
<div id="loading-indicator" class="alert alert-info mt-3">
  <i class="fa fa-spinner fa-spin"></i> Loading lightcurve data...
</div>

<!-- No data warning (hidden initially) -->
<div id="no-data-warning" class="alert alert-warning mt-3" style="display: none;">
  No lightcurve data available for <span id="no-data-mode"></span> mode.
  <span id="no-data-hint"></span>
</div>

<!-- Error message (hidden initially) -->
<div id="error-message" class="alert alert-danger mt-3" style="display: none;">
  <strong>Error loading data:</strong> <span id="error-text"></span>
</div>

<!-- Control Panel -->
<div class="control-panel" id="control-panel" style="display: none;">
  <h5 class="mb-3">Data Sources</h5>

  <div id="source-controls">
    <!-- Populated by JavaScript -->
  </div>

  <div class="mt-3">
    <button class="btn btn-sm btn-outline-primary me-2" onclick="resetOffsets()">
      <i class="fa fa-refresh"></i> Reset Controls
    </button>
    <button class="btn btn-sm btn-outline-primary me-2" onclick="enableAll()">
      <i class="fa fa-check-square-o"></i> Enable All
    </button>
    <button class="btn btn-sm btn-outline-primary" onclick="disableAll()">
      <i class="fa fa-square-o"></i> Disable All
    </button>
  </div>
</div>

<!-- Phase Folding Panel -->
<div class="control-panel mt-3" id="phase-panel" style="display: none;">
  <h5 class="mb-3">Phase Folding</h5>

  <div class="row g-2 align-items-center">
    <div class="col-auto">
      <label for="period-input" class="col-form-label col-form-label-sm">Period (days):</label>
    </div>
    <div class="col-auto">
      <input type="number" class="form-control form-control-sm" id="period-input"
             style="width: 120px;" step="0.001" min="0" placeholder="0 = off"
             onchange="updatePhaseFolding()">
    </div>
    <div class="col-auto">
      <label for="epoch-input" class="col-form-label col-form-label-sm">T₀ (MJD):</label>
    </div>
    <div class="col-auto">
      <input type="number" class="form-control form-control-sm" id="epoch-input"
             style="width: 120px;" step="0.001" value="0" placeholder="0"
             onchange="updatePhaseFolding()">
    </div>
    <div class="col-auto">
      <button class="btn btn-sm btn-outline-secondary" onclick="clearPhaseFolding()">
        <i class="fa fa-times"></i> Clear
      </button>
    </div>
    <div class="col-auto">
      <button class="btn btn-sm btn-primary" onclick="fitPeriod()" id="fit-period-btn">
        <i class="fa fa-calculator"></i> Fit Period
      </button>
    </div>
  </div>

  <div class="mt-2">
    <small class="text-muted">
      Set period to enable phase folding. Phase range: -0.6 to 1.6 with wrapped data.
      Use "Fit Period" to automatically find the best period using visible data sources.
    </small>
  </div>
</div>

<!-- Plot Container -->
<div id="plotly-container" style="width: 100%; height: 600px; display: none;"></div>

<script>
// Light curve data (loaded asynchronously)
let lightcurveData = [];

// Data mode constants
let dataMode = "{{ data_mode }}";  // 'magnitude' or 'flux'
let isMagnitudeMode = dataMode === 'magnitude';

// Track state of each series
const seriesState = {};

// Track whether plot has been initialized
let plotInitialized = false;

// Phase folding parameters
let phasePeriod = 0;  // Period in days (0 = disabled)
let phaseEpoch = 0;   // T0 in MJD

// Track data loading state
let dataLoaded = false;

// Initialize series state and create controls
function initializeControls() {
    const container = document.getElementById('source-controls');
    container.innerHTML = '';

    lightcurveData.forEach((series, index) => {
        // Initialize state
        seriesState[index] = {
            visible: true,
            offset: 0,
            markerSize: 4,
            color: series.color,
            defaultColor: series.color,
            data: series
        };

        // Create control element
        const control = document.createElement('div');
        control.className = 'source-control';
        control.innerHTML = `
            <div class="source-color" style="background-color: ${series.color};" id="color-display-${index}">
                <input type="color" class="color-input" id="color-${index}"
                       value="${series.color}" onchange="updateColor(${index})">
            </div>
            <div class="source-label">${series.label}</div>
            <div class="source-info">${series.n_points} points</div>
            <span class="control-label">Offset:</span>
            <input type="number" class="form-control form-control-sm offset-control"
                   id="offset-${index}" value="0" step="0.1"
                   onchange="updateOffset(${index})">
            <span class="control-label">Size:</span>
            <input type="number" class="form-control form-control-sm size-control"
                   id="size-${index}" value="4" step="0.5" min="0.5" max="20"
                   onchange="updateMarkerSize(${index})">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox"
                       id="toggle-${index}" checked
                       onchange="toggleSeries(${index})">
            </div>
        `;
        container.appendChild(control);
    });
}

// Calculate phase from MJD
function calculatePhase(mjd, period, epoch) {
    return ((mjd - epoch) % period) / period;
}

// Prepare data for phase-folded display
function preparePhaseData(series, period, epoch) {
    const phases = [];
    const values = [];
    const errs = [];
    const mjds = [];
    const datetimes = [];

    // Use appropriate data keys based on mode
    const dataKey = isMagnitudeMode ? 'mag' : 'flux';
    const errKey = isMagnitudeMode ? 'magerr' : 'flux_err';

    // Calculate phases for all points
    for (let i = 0; i < series.mjd.length; i++) {
        const phase = calculatePhase(series.mjd[i], period, epoch);

        // Normalize phase to [0, 1)
        const normalizedPhase = phase >= 0 ? phase : phase + 1;

        phases.push(normalizedPhase);
        values.push(series[dataKey][i]);
        errs.push(series[errKey][i]);
        mjds.push(series.mjd[i]);
        datetimes.push(series.datetime[i]);
    }

    // Wrap data to fill -0.6 to 1.6 range
    const wrappedPhases = [...phases];
    const wrappedValues = [...values];
    const wrappedErrs = [...errs];
    const wrappedMjds = [...mjds];
    const wrappedDatetimes = [...datetimes];

    // Add wrapped copies for phase > 0.4 at negative phases (for -0.6 to 0 range)
    for (let i = 0; i < phases.length; i++) {
        if (phases[i] >= 0.4) {
            wrappedPhases.push(phases[i] - 1);
            wrappedValues.push(values[i]);
            wrappedErrs.push(errs[i]);
            wrappedMjds.push(mjds[i]);
            wrappedDatetimes.push(datetimes[i]);
        }
    }

    // Add wrapped copies for phase < 0.6 at phase + 1 (for 1.0 to 1.6 range)
    for (let i = 0; i < phases.length; i++) {
        if (phases[i] < 0.6) {
            wrappedPhases.push(phases[i] + 1);
            wrappedValues.push(values[i]);
            wrappedErrs.push(errs[i]);
            wrappedMjds.push(mjds[i]);
            wrappedDatetimes.push(datetimes[i]);
        }
    }

    return {
        phases: wrappedPhases,
        values: wrappedValues,
        errs: wrappedErrs,
        mjds: wrappedMjds,
        datetimes: wrappedDatetimes
    };
}

// Update plot
function updatePlot() {
    const traces = [];
    const isPhaseFolded = phasePeriod > 0;

    // Determine value label and data keys based on mode
    const valueLabel = isMagnitudeMode ? 'Magnitude' : 'Normalized Flux';
    const dataKey = isMagnitudeMode ? 'mag' : 'flux';
    const errKey = isMagnitudeMode ? 'magerr' : 'flux_err';

    lightcurveData.forEach((series, index) => {
        const state = seriesState[index];
        if (!state.visible) return;

        let xData, yData, errData, customData, hoverTemplate;

        if (isPhaseFolded) {
            // Phase-folded mode
            const phaseData = preparePhaseData(series, phasePeriod, phaseEpoch);

            xData = phaseData.phases;
            yData = phaseData.values.map(v => v + state.offset);
            errData = phaseData.errs;
            customData = phaseData.mjds.map((mjd, i) => [
                mjd,
                phaseData.errs[i],
                phaseData.phases[i]
            ]);

            hoverTemplate =
                '<b>%{fullData.name}</b><br>' +
                'Phase: %{customdata[2]:.4f}<br>' +
                'MJD: %{customdata[0]:.2f}<br>' +
                valueLabel + ': %{y:.3f} ± %{customdata[1]:.3f}<br>' +
                '<extra></extra>';
        } else {
            // Time mode
            const values_with_offset = series[dataKey].map(v => v + state.offset);

            xData = series.datetime;
            yData = values_with_offset;
            errData = series[errKey];
            customData = series.mjd.map((mjd, i) => [mjd, series[errKey][i]]);

            hoverTemplate =
                '<b>%{fullData.name}</b><br>' +
                'Time: %{x}<br>' +
                'MJD: %{customdata[0]:.2f}<br>' +
                valueLabel + ': %{y:.3f} ± %{customdata[1]:.3f}<br>' +
                '<extra></extra>';
        }

        traces.push({
            x: xData,
            y: yData,
            customdata: customData,
            error_y: {
                type: 'data',
                array: errData,
                visible: true,
                color: state.color,
                thickness: 1,
                width: 0
            },
            mode: 'markers',
            type: 'scatter',
            name: series.label,
            marker: {
                color: state.color,
                size: state.markerSize,
            },
            hovertemplate: hoverTemplate,
        });
    });

    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        displaylogo: false,
    };

    // Determine plot title based on mode
    const titleText = isMagnitudeMode
        ? '{{ target.name }} - Multi-Survey Light Curve'
        : '{{ target.name }} - TESS Flux Light Curve';

    // Determine y-axis label based on mode
    const yAxisTitle = isMagnitudeMode ? 'Magnitude' : 'Normalized Flux';

    // Use newPlot for initial render, react for updates to preserve zoom state
    if (!plotInitialized) {
        const layout = {
            title: {
                text: titleText,
                font: { size: 18 }
            },
            xaxis: isPhaseFolded ? {
                title: `Phase (P = ${phasePeriod.toFixed(6)} days, T₀ = ${phaseEpoch.toFixed(2)} MJD)`,
                gridcolor: '#e0e0e0',
                range: [-0.6, 1.6],
                zeroline: false,
            } : {
                title: 'Universal Time (UT)',
                gridcolor: '#e0e0e0',
                zeroline: false,
            },
            yaxis: {
                title: yAxisTitle,
                autorange: isMagnitudeMode ? 'reversed' : true,  // Inverted for magnitudes, normal for flux
                gridcolor: '#e0e0e0',
                zeroline: false,
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                orientation: 'v',
                yanchor: 'top',
                y: 1,
                xanchor: 'right',
                x: 1
            },
            margin: {
                l: 60,
                r: 20,
                t: 60,
                b: 60
            },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            shapes: isPhaseFolded ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                },
                {
                    type: 'line',
                    x0: 1,
                    y0: 0,
                    x1: 1,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                }
            ] : (!isMagnitudeMode ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 1,
                    x1: 1,
                    y1: 1,
                    xref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash',
                        opacity: 0.5
                    }
                }
            ] : [])
        };
        Plotly.newPlot('plotly-container', traces, layout, config);
        plotInitialized = true;
    } else {
        // Get current axis ranges to preserve zoom
        const plotDiv = document.getElementById('plotly-container');
        const currentLayout = plotDiv.layout;

        const layout = {
            title: {
                text: titleText,
                font: { size: 18 }
            },
            xaxis: isPhaseFolded ? {
                title: `Phase (P = ${phasePeriod.toFixed(6)} days, T₀ = ${phaseEpoch.toFixed(2)} MJD)`,
                gridcolor: '#e0e0e0',
                range: [-0.6, 1.6],
                zeroline: false,
            } : {
                title: 'Universal Time (UT)',
                gridcolor: '#e0e0e0',
                // Preserve current range if it exists (only in time mode)
                range: currentLayout.xaxis.range,
                autorange: currentLayout.xaxis.autorange,
                zeroline: false,
            },
            yaxis: {
                title: yAxisTitle,
                gridcolor: '#e0e0e0',
                // Preserve current range if it exists
                range: currentLayout.yaxis.range,
                autorange: currentLayout.yaxis.autorange,
                zeroline: false,
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                orientation: 'v',
                yanchor: 'top',
                y: 1,
                xanchor: 'right',
                x: 1
            },
            margin: {
                l: 60,
                r: 20,
                t: 60,
                b: 60
            },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            shapes: isPhaseFolded ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 0,
                    x1: 0,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                },
                {
                    type: 'line',
                    x0: 1,
                    y0: 0,
                    x1: 1,
                    y1: 1,
                    yref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash'
                    }
                }
            ] : (!isMagnitudeMode ? [
                {
                    type: 'line',
                    x0: 0,
                    y0: 1,
                    x1: 1,
                    y1: 1,
                    xref: 'paper',
                    line: {
                        color: 'gray',
                        width: 1,
                        dash: 'dash',
                        opacity: 0.5
                    }
                }
            ] : [])
        };

        // Plotly.react updates the plot while preserving zoom/pan state
        Plotly.react('plotly-container', traces, layout, config);
    }
}

// Update phase folding parameters and redraw plot
function updatePhaseFolding() {
    const periodInput = document.getElementById('period-input');
    const epochInput = document.getElementById('epoch-input');

    phasePeriod = parseFloat(periodInput.value) || 0;
    phaseEpoch = parseFloat(epochInput.value) || 0;

    // Force reinitialize plot when switching modes
    if (plotInitialized) {
        plotInitialized = false;
        updatePlot();
        plotInitialized = true;
    }
}

// Clear phase folding
function clearPhaseFolding() {
    document.getElementById('period-input').value = '';
    document.getElementById('epoch-input').value = '0';
    phasePeriod = 0;
    phaseEpoch = 0;

    // Force reinitialize plot
    if (plotInitialized) {
        plotInitialized = false;
        updatePlot();
        plotInitialized = true;
    }
}

// Get CSRF token from cookies
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Fit period using Lomb-Scargle multiband periodogram
function fitPeriod() {
    // Check if data is loaded
    if (!dataLoaded) {
        alert('Data is still loading. Please wait...');
        return;
    }

    // Collect visible series data
    const visibleSeries = [];
    const dataKey = isMagnitudeMode ? 'mag' : 'flux';
    const errKey = isMagnitudeMode ? 'magerr' : 'flux_err';

    lightcurveData.forEach((series, index) => {
        const state = seriesState[index];
        if (!state.visible) return;

        visibleSeries.push({
            mjd: series.mjd,
            values: series[dataKey],
            errors: series[errKey],
            label: series.label
        });
    });

    if (visibleSeries.length === 0) {
        alert('No visible series to fit! Please enable at least one data source.');
        return;
    }

    // Disable button and show loading state
    const btn = document.getElementById('fit-period-btn');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Fitting...';

    // Make AJAX request
    fetch(`/targets/{{ target_id }}/fit_period/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            series: visibleSeries
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(err.error || 'Server error');
            });
        }
        return response.json();
    })
    .then(data => {
        // Update period and epoch inputs
        document.getElementById('period-input').value = data.period.toFixed(6);
        document.getElementById('epoch-input').value = data.epoch.toFixed(2);

        // Update global variables
        phasePeriod = data.period;
        phaseEpoch = data.epoch;

        // Show results
        let message = `Period fit successful!\n\n` +
            `Best period: ${data.period.toFixed(6)} days\n` +
            `Epoch (T₀): ${data.epoch.toFixed(2)} MJD\n` +
            `Power: ${data.power.toFixed(4)}\n`;

        if (data.fap !== undefined) {
            const fapStr = data.fap < 0.0001 ? data.fap.toExponential(2) : data.fap.toFixed(4);
            message += `False Alarm Prob: ${fapStr}\n`;
        } else {
            message += `False Alarm Prob: N/A (multiband fit)\n`;
        }

        message += `\nFitted ${data.n_points} points from ${data.n_series} series.`;

        alert(message);

        // Update plot with phase folding
        updatePhaseFolding();
    })
    .catch(error => {
        console.error('Error fitting period:', error);
        alert(`Error fitting period: ${error.message}\n\nSee console for details.`);
    })
    .finally(() => {
        // Re-enable button
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    });
}

// Toggle series visibility
function toggleSeries(index) {
    const checkbox = document.getElementById(`toggle-${index}`);
    seriesState[index].visible = checkbox.checked;
    updatePlot();
}

// Update offset for a series
function updateOffset(index) {
    const input = document.getElementById(`offset-${index}`);
    seriesState[index].offset = parseFloat(input.value) || 0;
    updatePlot();
}

// Update marker size for a series
function updateMarkerSize(index) {
    const input = document.getElementById(`size-${index}`);
    seriesState[index].markerSize = parseFloat(input.value) || 4;
    updatePlot();
}

// Update color for a series
function updateColor(index) {
    const input = document.getElementById(`color-${index}`);
    const colorDisplay = document.getElementById(`color-display-${index}`);
    seriesState[index].color = input.value;
    colorDisplay.style.backgroundColor = input.value;
    updatePlot();
}

// Reset all offsets, marker sizes, and colors
function resetOffsets() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].offset = 0;
        seriesState[index].markerSize = 4;
        seriesState[index].color = seriesState[index].defaultColor;
        document.getElementById(`offset-${index}`).value = 0;
        document.getElementById(`size-${index}`).value = 4;
        document.getElementById(`color-${index}`).value = seriesState[index].defaultColor;
        document.getElementById(`color-display-${index}`).style.backgroundColor = seriesState[index].defaultColor;
    });
    updatePlot();
}

// Enable all series
function enableAll() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].visible = true;
        document.getElementById(`toggle-${index}`).checked = true;
    });
    updatePlot();
}

// Disable all series
function disableAll() {
    lightcurveData.forEach((series, index) => {
        seriesState[index].visible = false;
        document.getElementById(`toggle-${index}`).checked = false;
    });
    updatePlot();
}

// Switch display mode while preserving period/epoch
function switchMode(newMode) {
    // Get current period and epoch values
    const periodInput = document.getElementById('period-input');
    const epochInput = document.getElementById('epoch-input');

    const period = periodInput.value;
    const epoch = epochInput.value;

    // Build URL with mode and optional period/epoch parameters
    let url = `?mode=${newMode}`;

    if (period) {
        url += `&period=${encodeURIComponent(period)}`;
    }

    if (epoch) {
        url += `&epoch=${encodeURIComponent(epoch)}`;
    }

    // Update URL without reloading (for better UX and browser history)
    window.history.pushState({mode: newMode}, '', url);

    // Update mode toggle button states
    document.querySelectorAll('.control-panel .btn-group button').forEach(btn => {
        if (btn.textContent.includes('Magnitudes')) {
            if (newMode === 'magnitude') {
                btn.classList.remove('btn-outline-primary');
                btn.classList.add('btn-primary');
            } else {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline-primary');
            }
        } else if (btn.textContent.includes('TESS Flux')) {
            if (newMode === 'flux') {
                btn.classList.remove('btn-outline-primary');
                btn.classList.add('btn-primary');
            } else {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline-primary');
            }
        }
    });

    // Reset plot state
    plotInitialized = false;

    // Reload data for new mode
    loadLightcurveData();
}

// Get URL parameter by name
function getUrlParameter(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    const results = regex.exec(location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
}

// Load lightcurve data asynchronously
function loadLightcurveData() {
    // Get mode from URL or use default
    const mode = getUrlParameter('mode') || '{{ data_mode }}';

    // Show loading indicator
    document.getElementById('loading-indicator').style.display = 'block';
    document.getElementById('no-data-warning').style.display = 'none';
    document.getElementById('error-message').style.display = 'none';
    document.getElementById('control-panel').style.display = 'none';
    document.getElementById('phase-panel').style.display = 'none';

    // Make AJAX request to load data
    fetch(`/targets/{{ target_id }}/lightcurve_data/?mode=${mode}`)
        .then(response => {
            if (!response.ok) {
                return response.json().then(err => {
                    throw new Error(err.error || 'Server error');
                });
            }
            return response.json();
        })
        .then(result => {
            // Hide loading indicator
            document.getElementById('loading-indicator').style.display = 'none';

            // Update global variables
            lightcurveData = result.data;
            dataMode = result.mode;
            isMagnitudeMode = dataMode === 'magnitude';
            dataLoaded = true;

            if (result.no_data) {
                // Show no-data warning
                document.getElementById('no-data-warning').style.display = 'block';
                document.getElementById('no-data-mode').textContent = dataMode;
                if (dataMode === 'flux') {
                    document.getElementById('no-data-hint').textContent = 'Try acquiring TESS data first.';
                } else {
                    document.getElementById('no-data-hint').textContent = '';
                }
            } else {
                // Show controls, plot container, and initialize
                document.getElementById('control-panel').style.display = 'block';
                document.getElementById('phase-panel').style.display = 'block';
                document.getElementById('plotly-container').style.display = 'block';

                // Restore period and epoch from URL parameters if present
                const urlPeriod = getUrlParameter('period');
                const urlEpoch = getUrlParameter('epoch');

                if (urlPeriod) {
                    document.getElementById('period-input').value = urlPeriod;
                    phasePeriod = parseFloat(urlPeriod) || 0;
                }

                if (urlEpoch) {
                    document.getElementById('epoch-input').value = urlEpoch;
                    phaseEpoch = parseFloat(urlEpoch) || 0;
                }

                // Initialize controls and plot
                initializeControls();
                updatePlot();
            }
        })
        .catch(error => {
            console.error('Error loading lightcurve data:', error);

            // Hide loading indicator
            document.getElementById('loading-indicator').style.display = 'none';

            // Show error message
            document.getElementById('error-message').style.display = 'block';
            document.getElementById('error-text').textContent = error.message;
        });
}

// Handle browser back/forward buttons
window.addEventListener('popstate', function(event) {
    // Reset plot state
    plotInitialized = false;

    // Reload data for current URL
    loadLightcurveData();
});

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadLightcurveData();
});
</script>

{% endblock %}
